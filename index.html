<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<title>ç‹—ç‹—åƒéª¨é ­ï½œDog Park Snake</title>

<style>
  body {
    margin: 0;
    background: #000;
    color: #fff;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }

  canvas {
    border-radius: 12px;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    background: #000;
    display: block;
  }

  /* --- ä¸»é¸å–® --- */
  #start-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(1px);
    z-index: 20;
    text-shadow: 0 2px 5px rgba(0,0,0,0.4);
  }

  .title {
    font-size: 38px;
    margin-bottom: 5px;
  }

  .subtitle {
    font-size: 20px;
    margin-bottom: 18px;
  }

  .input-row {
    margin-bottom: 8px;
  }

  .input-row label {
    margin-right: 6px;
  }

  .name-input {
    width: 220px;
    padding: 8px 10px;
    border-radius: 8px;
    border: none;
    font-size: 16px;
  }

  .mode-buttons {
    margin-top: 10px;
    margin-bottom: 20px;
  }

  .big-btn {
    width: 220px;
    padding: 12px;
    margin: 8px;
    font-size: 18px;
    font-weight: bold;
    border-radius: 12px;
    border: none;
    cursor: pointer;
    background: #4ade80;
    color: #000;
    transition: 0.2s;
  }
  .big-btn.secondary {
    background: #22c55e;
  }
  .big-btn:hover {
    transform: scale(1.05);
    filter: brightness(1.05);
  }

  .tips {
    font-size: 13px;
    opacity: 0.85;
    margin-bottom: 12px;
  }

  /* --- æ’è¡Œæ¦œ --- */
  #leaderboard {
    background: rgba(15,23,42,0.9);
    padding: 12px 18px;
    border-radius: 12px;
    max-width: 320px;
  }

  #leaderboard h3 {
    margin: 0 0 6px 0;
    font-size: 18px;
  }

  #leaderboard small {
    opacity: 0.7;
  }

  #leaderboard-list {
    list-style: decimal;
    padding-left: 20px;
    margin: 6px 0 0 0;
    font-size: 14px;
    text-align: left;
  }

  #leaderboard-list li span.name {
    font-weight: 600;
  }
  #leaderboard-list li span.score {
    color: #facc15;
  }

  /* --- å€’æ•¸å‹•ç•« --- */
  #countdown {
    position: absolute;
    top: 45%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: 88px;
    z-index: 30;
    display: none;
    animation: pop 0.4s ease-out;
  }

  @keyframes pop {
    0%   { transform: translate(-50%, -50%) scale(0.2); opacity: 0; }
    70%  { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1);   opacity: 1; }
  }
</style>
</head>
<body>

<!-- ä¸»é¸å–® -->
<div id="start-screen">
  <h1 class="title">ğŸ• ç‹—ç‹—åƒéª¨é ­ Snake</h1>
  <div class="subtitle">é¸æ“‡éŠæˆ²æ¨¡å¼</div>

  <div class="input-row">
    <label for="player-name">ç©å®¶åç¨±ï¼š</label>
    <input id="player-name" class="name-input" type="text" placeholder="ä¾‹å¦‚ï¼šLexi" />
  </div>
  <div class="tips">
    âŒ¨ å–®äººï¼šæ–¹å‘éµ / WASDã€€|ã€€é›™äººï¼šP1=WASDã€P2=æ–¹å‘éµã€€|ã€€Rï¼šå†ç©ä¸€æ¬¡ã€€Mï¼šå›ä¸»é¸å–®
  </div>

  <div class="mode-buttons">
    <button class="big-btn" id="btn-start-single">å–®äººæ’è¡Œæ¨¡å¼</button>
    <button class="big-btn secondary" id="btn-start-versus">é›™äººå°æˆ°æ¨¡å¼</button>
  </div>

  <div id="leaderboard">
    <h3>ğŸ† å–®äººæ’è¡Œæ¦œ</h3>
    <small>åªè¨˜éŒ„æœ¬å°é›»è…¦å‰ 10 åå–”</small>
    <ol id="leaderboard-list"></ol>
  </div>
</div>

<!-- IG Reels é¢¨æ ¼å€’æ•¸ -->
<div id="countdown"></div>

<canvas id="game"></canvas>

<script>
/* ------------------------------------------------------
   ğŸ¶ åŸºæœ¬è¨­å®š
------------------------------------------------------ */
const CELL_SIZE = 24;
const GRID_W = 30;
const GRID_H = 30;
const WIDTH   = CELL_SIZE * GRID_W;
const HEIGHT  = CELL_SIZE * GRID_H;

// å‹•æ…‹é€Ÿåº¦ï¼šå¾æ¯”è¼ƒæ…¢é–‹å§‹ï¼Œæ¯ 10 åˆ†åŠ å¿«ä¸€é»
const BASE_SPEED = 180;   // èµ·å§‹é€Ÿåº¦ï¼ˆæ¯«ç§’ï¼Œè¶Šå¤§è¶Šæ…¢ï¼‰
const MIN_SPEED  = 70;    // æœ€å¿«ä¸è¶…éé€™éº¼å¿«
const SPEED_STEP = 15;    // æ¯ä¸€ç´šï¼ˆ10 åˆ†ï¼‰é€Ÿåº¦ç¸®çŸ­å¤šå°‘ ms

const canvas = document.getElementById("game");
const ctx    = canvas.getContext("2d");
canvas.width  = WIDTH;
canvas.height = HEIGHT;

/* ------------------------------------------------------
   ğŸµ éŸ³æ•ˆ
------------------------------------------------------ */
const boneSound       = new Audio("bone.wav");
const gameoverSound   = new Audio("gameover_waiwai.wav");
const countdownBeep   = new Audio("countdown.wav");
boneSound.volume      = 1.0;
gameoverSound.volume  = 1.0;
countdownBeep.volume  = 1.0;

/* ------------------------------------------------------
   ğŸ† æ’è¡Œæ¦œï¼ˆlocalStorageï¼Œå–®äººç”¨ï¼‰
------------------------------------------------------ */
const LEADERBOARD_KEY = "dogpark_snake_leaderboard_v1";
let leaderboard = [];
let currentPlayerName = "åŒ¿åç‹—ç‹—";

function loadLeaderboard() {
  try {
    const raw = localStorage.getItem(LEADERBOARD_KEY);
    leaderboard = raw ? JSON.parse(raw) : [];
  } catch (e) {
    leaderboard = [];
  }
}

function saveLeaderboard() {
  try {
    localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(leaderboard));
  } catch (e) {}
}

function addScoreToLeaderboard(name, score) {
  leaderboard.push({ name, score, time: Date.now() });
  leaderboard.sort((a, b) => {
    if (b.score !== a.score) return b.score - a.score;
    return a.time - b.time;
  });
  leaderboard = leaderboard.slice(0, 10);
  saveLeaderboard();
  renderLeaderboard();
}

function renderLeaderboard() {
  const list = document.getElementById("leaderboard-list");
  list.innerHTML = "";

  if (!leaderboard.length) {
    const li = document.createElement("li");
    li.textContent = "ç›®å‰é‚„æ²’æœ‰ç´€éŒ„ï¼Œå¿«ä¾†ç•¶ç¬¬ä¸€åï¼";
    list.appendChild(li);
    return;
  }

  leaderboard.forEach(item => {
    const li = document.createElement("li");

    const nameSpan = document.createElement("span");
    nameSpan.className = "name";
    nameSpan.textContent = item.name || "åŒ¿åç‹—ç‹—";

    const scoreSpan = document.createElement("span");
    scoreSpan.className = "score";
    scoreSpan.textContent = `ã€€${item.score} åˆ†`;

    li.appendChild(nameSpan);
    li.appendChild(scoreSpan);
    list.appendChild(li);
  });
}

/* ------------------------------------------------------
   ğŸ• éŠæˆ²ç‹€æ…‹è®Šæ•¸
------------------------------------------------------ */
// å–®äºº
let snake;
let direction;
let pendingDirection;
let food;
let score = 0;
let hasRecordedThisGame = false;

// é›™äºº
let snake1, snake2;
let dir1, dir2;
let pendingDir1, pendingDir2;
let score1 = 0, score2 = 0;
let versusResultText = "";

// é€šç”¨
let gameOver = false;
let gameMode = null;  // "single" | "versus" | null
let heartEffects = [];

// å‹•æ…‹é€Ÿåº¦ç”¨
let lastMoveTime = 0;

/* ------------------------------------------------------
   ğŸ® ä¸»é¸å–®èˆ‡å•Ÿå‹•
------------------------------------------------------ */
const startScreen   = document.getElementById("start-screen");
const countdownElem = document.getElementById("countdown");

document.getElementById("btn-start-single").onclick = () => {
  const inputName = document.getElementById("player-name").value.trim();
  currentPlayerName = inputName || "åŒ¿åç‹—ç‹—";
  startGameSequence("single");
};

document.getElementById("btn-start-versus").onclick = () => {
  startGameSequence("versus");
};

function startGameSequence(mode) {
  gameMode = mode;
  startScreen.style.display = "none";
  startCountdown(() => {
    if (mode === "single") {
      resetGameSingle();
    } else {
      resetGameVersus();
    }
    lastMoveTime = 0; // å€’æ•¸å®Œé‡æ–°è¨ˆæ™‚
  });
}

/* ------------------------------------------------------
   â±ï¸ IG Reels é¢¨æ ¼å€’æ•¸ + å€’æ•¸éŸ³æ•ˆ
------------------------------------------------------ */
function startCountdown(callback) {
  countdownElem.style.display = "block";
  let num = 3;

  function run() {
    countdownElem.innerText = num === 0 ? "GO!" : num;
    countdownElem.style.animation = "none";
    countdownElem.offsetHeight; // å¼·åˆ¶ reflow
    countdownElem.style.animation = "pop 0.4s ease-out";

    // å€’æ•¸éŸ³æ•ˆï¼ˆ3ã€2ã€1ã€GO éƒ½æ•²ä¸€ä¸‹ï¼‰
    try {
      countdownBeep.currentTime = 0;
      countdownBeep.play().catch(()=>{});
    } catch (e) {}

    if (num === 0) {
      setTimeout(() => {
        countdownElem.style.display = "none";
        callback();
      }, 500);
      return;
    }
    num--;
    setTimeout(run, 800);
  }
  run();
}

/* ------------------------------------------------------
   ğŸ”„ éŠæˆ²é‡ç½®
------------------------------------------------------ */
function resetGameSingle() {
  snake = [
    { x: 1, y: 1 },//é ­
    { x: 0, y: 1 },
    { x: 0, y: 2 },
  ];
  direction        = { x: 1, y: 0 };
  pendingDirection = { x: 1, y: 0 };
  score            = 0;
  gameOver         = false;
  hasRecordedThisGame = false;
  heartEffects     = [];
  food             = randomFoodSingle();
}

function resetGameVersus() {
  // P1 å·¦ä¸Š
  snake1 = [
    { x: 1, y: 1 },  // é ­
    { x: 0, y: 1 },
    { x: 0, y: 2 },
  ];
  dir1        = { x: 1,  y: 0 };
  pendingDir1 = { x: 1,  y: 0 };

  // P2 å·¦ä¸‹
  snake2 = [
    { x: GRID_W - 2, y: GRID_H - 2 },  // é ­
    { x: GRID_W - 1, y: GRID_H - 2 },
    { x: GRID_W - 1, y: GRID_H - 3 },
  ];
  dir2        = { x: 1,  y: 0 };
  pendingDir2 = { x: 1,  y: 0 };

  score1 = 0;
  score2 = 0;
  gameOver = false;
  versusResultText = "";
  heartEffects = [];
  food = randomFoodVersus();
}

/* ------------------------------------------------------
   ğŸ¦´ é£Ÿç‰©ç”¢ç”Ÿ
------------------------------------------------------ */
function randomFoodSingle() {
  while (true) {
    const x = Math.floor(Math.random() * GRID_W);
    const y = Math.floor(Math.random() * GRID_H);
    if (!snake.some(s => s.x === x && s.y === y)) {
      return { x, y };
    }
  }
}

function randomFoodVersus() {
  while (true) {
    const x = Math.floor(Math.random() * GRID_W);
    const y = Math.floor(Math.random() * GRID_H);
    if (
      !snake1.some(s => s.x === x && s.y === y) &&
      !snake2.some(s => s.x === x && s.y === y)
    ) {
      return { x, y };
    }
  }
}

/* ------------------------------------------------------
   âš¡ ä¾åˆ†æ•¸è¨ˆç®—ç›®å‰é€Ÿåº¦
------------------------------------------------------ */
function getCurrentSpeed() {
  if (!gameMode) return BASE_SPEED;

  if (gameMode === "single") {
    const level = Math.floor(score / 10);           // æ¯ 10 åˆ†å‡ä¸€ç´š
    return Math.max(BASE_SPEED - level * SPEED_STEP, MIN_SPEED);
  } else {
    const total = score1 + score2;                  // é›™äººç”¨ç¸½åˆ†ä¾†åŠ é€Ÿ
    const level = Math.floor(total / 10);
    return Math.max(BASE_SPEED - level * SPEED_STEP, MIN_SPEED);
  }
}

/* ------------------------------------------------------
   ğŸ¹ éµç›¤æ§åˆ¶
------------------------------------------------------ */
document.addEventListener("keydown", e => {
  const key = e.key;

  if (key === "r" || key === "R") {
    if (gameMode === "single" && gameOver) resetGameSingle();
    if (gameMode === "versus" && gameOver) resetGameVersus();
    return;
  }

  if (key === "m" || key === "M") {
    if (gameOver) {
      gameMode = null;
      startScreen.style.display = "flex";
    }
    return;
  }

  if (!gameMode || gameOver) return;

  // å–®äººï¼šWASD & æ–¹å‘éµéƒ½æ§åˆ¶åŒä¸€éš»
  if (gameMode === "single") {
    switch (key) {
      case "ArrowUp":
      case "w":
      case "W":
        changeDirSingle(0, -1); break;
      case "ArrowDown":
      case "s":
      case "S":
        changeDirSingle(0, 1); break;
      case "ArrowLeft":
      case "a":
      case "A":
        changeDirSingle(-1, 0); break;
      case "ArrowRight":
      case "d":
      case "D":
        changeDirSingle(1, 0); break;
    }
  }

  // é›™äººï¼šP1=WASD, P2=æ–¹å‘éµ
  if (gameMode === "versus") {
    switch (key) {
      // P1 (WASD)
      case "w": case "W":
        changeDir1(0, -1); break;
      case "s": case "S":
        changeDir1(0, 1); break;
      case "a": case "A":
        changeDir1(-1, 0); break;
      case "d": case "D":
        changeDir1(1, 0); break;

      // P2 (æ–¹å‘éµ)
      case "ArrowUp":
        changeDir2(0, -1); break;
      case "ArrowDown":
        changeDir2(0, 1); break;
      case "ArrowLeft":
        changeDir2(-1, 0); break;
      case "ArrowRight":
        changeDir2(1, 0); break;
    }
  }
});

function changeDirSingle(dx, dy) {
  if (dx === -direction.x && dy === -direction.y) return;
  pendingDirection = { x: dx, y: dy };
}

function changeDir1(dx, dy) {
  if (dx === -dir1.x && dy === -dir1.y) return;
  pendingDir1 = { x: dx, y: dy };
}

function changeDir2(dx, dy) {
  if (dx === -dir2.x && dy === -dir2.y) return;
  pendingDir2 = { x: dx, y: dy };
}

/* ------------------------------------------------------
   ğŸ• å–®äººç§»å‹•é‚è¼¯ï¼ˆç©¿ç‰†ï¼Œä¸å‡ºç•Œæ­»äº¡ï¼‰
------------------------------------------------------ */
function moveSingle() {
  const head = snake[0];

  // âœ… ç©¿ç‰†ï¼šç”¨ç’°ç‹€åº§æ¨™
  const newHead = {
    x: (head.x + direction.x + GRID_W) % GRID_W,
    y: (head.y + direction.y + GRID_H) % GRID_H
  };

  // æ’åˆ°è‡ªå·±æ‰æœƒæ­»
  if (snake.some(s => s.x === newHead.x && s.y === newHead.y)) {
    triggerGameOverSingle();
    return;
  }

  snake.unshift(newHead);

  if (newHead.x === food.x && newHead.y === food.y) {
    score += 1;
    boneSound.currentTime = 0;
    boneSound.play().catch(()=>{});

    heartEffects.push({
      x: newHead.x * CELL_SIZE + CELL_SIZE / 2,
      y: newHead.y * CELL_SIZE + CELL_SIZE / 2,
      life: 12,
    });

    food = randomFoodSingle();
  } else {
    snake.pop();
  }
}

function triggerGameOverSingle() {
  if (gameOver) return;
  gameOver = true;
  gameoverSound.currentTime = 0;
  gameoverSound.play().catch(()=>{});

  if (gameMode === "single" && !hasRecordedThisGame) {
    hasRecordedThisGame = true;
    addScoreToLeaderboard(currentPlayerName, score);
  }
}

/* ------------------------------------------------------
   ğŸ•ğŸ• é›™äººç§»å‹•é‚è¼¯ï¼ˆç©¿ç‰†ï¼Œæ’è‡ªå·±/å°æ‰‹æ‰æ­»ï¼‰
------------------------------------------------------ */
function moveVersus() {
  const head1 = snake1[0];
  const head2 = snake2[0];

  // âœ… ç©¿ç‰†
  const newHead1 = {
    x: (head1.x + dir1.x + GRID_W) % GRID_W,
    y: (head1.y + dir1.y + GRID_H) % GRID_H
  };
  const newHead2 = {
    x: (head2.x + dir2.x + GRID_W) % GRID_W,
    y: (head2.y + dir2.y + GRID_H) % GRID_H
  };

  let dead1 = false;
  let dead2 = false;

  // æ’åˆ°è‡ªå·±
  if (snake1.some(s => s.x === newHead1.x && s.y === newHead1.y)) dead1 = true;
  if (snake2.some(s => s.x === newHead2.x && s.y === newHead2.y)) dead2 = true;

  // æ’åˆ°å°æ–¹èº«é«”
  if (snake2.some(s => s.x === newHead1.x && s.y === newHead1.y)) dead1 = true;
  if (snake1.some(s => s.x === newHead2.x && s.y === newHead2.y)) dead2 = true;

  // é ­å°æ’
  if (newHead1.x === newHead2.x && newHead1.y === newHead2.y) {
    dead1 = true;
    dead2 = true;
  }

  if (dead1 || dead2) {
    triggerGameOverVersus(dead1, dead2);
    return;
  }

  // éƒ½é‚„æ´»è‘— â†’ å‰é€²
  snake1.unshift(newHead1);
  snake2.unshift(newHead2);

  const p1Eat = (newHead1.x === food.x && newHead1.y === food.y);
  const p2Eat = (newHead2.x === food.x && newHead2.y === food.y);

  if (p1Eat || p2Eat) {
    boneSound.currentTime = 0;
    boneSound.play().catch(()=>{});
  }

  if (p1Eat) {
    score1 += 1;
    heartEffects.push({
      x: newHead1.x * CELL_SIZE + CELL_SIZE / 2,
      y: newHead1.y * CELL_SIZE + CELL_SIZE / 2,
      life: 12,
    });
  } else {
    snake1.pop();
  }

  if (p2Eat) {
    score2 += 1;
    heartEffects.push({
      x: newHead2.x * CELL_SIZE + CELL_SIZE / 2,
      y: newHead2.y * CELL_SIZE + CELL_SIZE / 2,
      life: 12,
    });
  } else {
    snake2.pop();
  }

  if (p1Eat || p2Eat) {
    food = randomFoodVersus();
  }
}

function triggerGameOverVersus(dead1, dead2) {
  if (gameOver) return;
  gameOver = true;
  gameoverSound.currentTime = 0;
  gameoverSound.play().catch(()=>{});

  if (dead1 && !dead2) {
    versusResultText = "ç©å®¶2 å‹åˆ©ï¼";
  } else if (!dead1 && dead2) {
    versusResultText = "ç©å®¶1 å‹åˆ©ï¼";
  } else {
    versusResultText = "å¹³æ‰‹ï¼";
  }
}

/* ------------------------------------------------------
   ğŸ¨ èƒŒæ™¯ç¹ªè£½ï¼ˆå¤©ç©º + è‰åœ° + å°è·¯ + æ¨¹ + å¤ªé™½ï¼‰
------------------------------------------------------ */
function drawBackground() {
  // å¤©ç©º
  ctx.fillStyle = "#9fd5ff";
  ctx.fillRect(0, 0, WIDTH, HEIGHT * 0.4);

  // è‰åœ°
  ctx.fillStyle = "#15803d";
  ctx.fillRect(0, HEIGHT * 0.4, WIDTH, HEIGHT * 0.6);

  // å°è·¯
  const pathW = CELL_SIZE * 4;
  ctx.fillStyle = "#4b5563";
  ctx.fillRect(WIDTH/2 - pathW/2, HEIGHT * 0.4, pathW, HEIGHT * 0.6);

  // æ¨¹æœ¨
  const treeXs = [CELL_SIZE * 3, CELL_SIZE * 7, CELL_SIZE * 22, CELL_SIZE * 26];
  for (const x of treeXs) {
    // æ¨¹å¹¹
    ctx.fillStyle = "#92400e";
    ctx.fillRect(x - 6, HEIGHT * 0.4 - 10, 12, 40);

    // æ¨¹å† 
    ctx.beginPath();
    ctx.fillStyle = "#16a34a";
    ctx.ellipse(
      x,
      HEIGHT * 0.4 - 20,
      20,
      24,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  // å¤ªé™½
  ctx.font = "28px 'Apple Color Emoji'";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillText("â˜€ï¸", WIDTH - 60, 10);
}

/* ------------------------------------------------------
   ğŸ¨ ç•«é¢æ¸²æŸ“
------------------------------------------------------ */
function draw() {
  ctx.clearRect(0, 0, WIDTH, HEIGHT);
  drawBackground();

  if (!gameMode) return;

  // åˆ†æ•¸
  ctx.textBaseline = "top";
  ctx.font = "20px Arial";
  ctx.fillStyle = "#ffffff";

  if (gameMode === "single") {
    ctx.textAlign = "left";
    ctx.fillText("Score: " + score, 10, 10);
  } else if (gameMode === "versus") {
    ctx.textAlign = "left";
    ctx.fillText("P1: " + score1, 10, 10);

    ctx.textAlign = "right";
    ctx.fillText("P2: " + score2, WIDTH - 10, 10);
  }

  // é£Ÿç‰©
  if (food) {
    const fx = food.x * CELL_SIZE + CELL_SIZE / 2;
    const fy = food.y * CELL_SIZE + CELL_SIZE / 2;
    ctx.font = "24px 'Apple Color Emoji'";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("ğŸ¦´", fx, fy);
  }

  // ç‹—ç‹—
  ctx.font = "24px 'Apple Color Emoji'";
  if (gameMode === "single" && snake) {
    for (const seg of snake) {
      const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;
      const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;
      ctx.fillText("ğŸ•", cx, cy);
    }
  }

  if (gameMode === "versus") {
    if (snake1) {
      for (const seg of snake1) {
        const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;
        const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;
        ctx.fillText("ğŸ•", cx, cy); // P1
      }
    }
    if (snake2) {
      for (const seg of snake2) {
        const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;
        const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;
        ctx.fillText("ğŸ¶", cx, cy); // P2
      }
    }
  }

  // â¤ï¸ æ„›å¿ƒç‰¹æ•ˆ
  const nextHearts = [];
  for (const h of heartEffects) {
    ctx.font = "20px 'Apple Color Emoji'";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("â¤ï¸", h.x, h.y);
    h.y -= 2;
    h.life -= 1;
    if (h.life > 0) nextHearts.push(h);
  }
  heartEffects = nextHearts;

  // Game Over ç•«é¢
  if (gameOver) {
    ctx.fillStyle = "rgba(15,23,42,0.9)";
    const w = 360, h = 160;
    const x = WIDTH / 2 - w / 2;
    const y = HEIGHT / 2 - h / 2;
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = "white";
    ctx.strokeRect(x, y, w, h);

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#f97373";
    ctx.font = "26px Arial";

    if (gameMode === "versus" && versusResultText) {
      ctx.fillText(versusResultText, WIDTH / 2, HEIGHT / 2 - 25);
      ctx.font = "16px Arial";
      ctx.fillStyle = "#ffffff";
      ctx.fillText(
        `P1ï¼š${score1} åˆ†    P2ï¼š${score2} åˆ†`,
        WIDTH / 2,
        HEIGHT / 2 + 2
      );
    } else {
      ctx.fillText("Game Over", WIDTH / 2, HEIGHT / 2 - 10);
    }

    ctx.font = "16px Arial";
    ctx.fillStyle = "#ffffff";
    ctx.fillText("Rï¼šå†ç©ä¸€æ¬¡   Mï¼šå›ä¸»é¸å–®", WIDTH / 2, HEIGHT / 2 + 35);
  }
}

/* ------------------------------------------------------
   ğŸ” éŠæˆ²è¿´åœˆï¼ˆç”¨ requestAnimationFrame + å‹•æ…‹é€Ÿåº¦ï¼‰
------------------------------------------------------ */
function gameLoop(timestamp) {
  // åˆæ¬¡å‘¼å«æ™‚ timestamp æœƒæœ‰å€¼
  if (!lastMoveTime) lastMoveTime = timestamp;

  const nowSpeed = getCurrentSpeed();
  const delta = timestamp - lastMoveTime;

  if (gameMode && !gameOver && delta >= nowSpeed) {
    lastMoveTime = timestamp;

    if (gameMode === "single") {
      direction = { ...pendingDirection };
      moveSingle();
    } else if (gameMode === "versus") {
      dir1 = { ...pendingDir1 };
      dir2 = { ...pendingDir2 };
      moveVersus();
    }
  }

  draw();
  requestAnimationFrame(gameLoop);
}

/* ------------------------------------------------------
   ğŸš€ å•Ÿå‹•ï¼šè¼‰å…¥æ’è¡Œæ¦œ + ç•«å‡ºèƒŒæ™¯çµ¦ä¸»ç•«é¢
------------------------------------------------------ */
loadLeaderboard();
renderLeaderboard();
draw();   // å…ˆç•«ä¸€å¼µèƒŒæ™¯çµ¦ä¸»é¸å–®ç•¶åº•
requestAnimationFrame(gameLoop);
</script>
</body>
</html>

